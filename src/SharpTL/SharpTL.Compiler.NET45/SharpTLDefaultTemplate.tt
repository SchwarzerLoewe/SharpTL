<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="SharpTL.Compiler.Annotations" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the SharpTL compiler (https://github.com/inTagger/SharpTL).
//     Generated at <#=DateTime.Now #>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using SharpTL;

namespace <#=_templateVars.Namespace #>
{
	// TL constructors.

<#
    // Writing constructors with common types.
	WriteConstructors(_templateVars.Schema.Constructors, _templateVars.Schema.Types);
	
	// Writing constructors without common types, because this is methods.
	// Hence method constructor is actually bunch of args to a method, which knows how to serialize itself.
	WriteConstructors(_templateVars.Schema.Methods, null);
#>
	
	// TL types.

<#
foreach (TLType type in _templateVars.Schema.Types)
{
#>
	[TLType(<#=type.Constructors.Select(constructor => string.Format("typeof({0})", constructor.Name)).Aggregate((s, s1) => s + ", " + s1)
    #>)]
	public abstract partial class <#=type.Name #>
	{
	}

<#
}
#>

	// TL methods.

	public interface ITLMethods
	{
<#
    foreach (var method in _templateVars.Schema.Methods)
    {
#>
		<#=method.Type.BuiltInName#> <#=method.Name#>(<#=method.Name#> args);
<#        
    }
#>
	}
}
<#+[UsedImplicitly] private TemplateVars _templateVars; #>
<#+
private void WriteConstructors(IEnumerable<TLCombinator> constructors, IEnumerable<TLType> types)
{
    List<TLType> typesList = types != null ? types.ToList() : null;
    foreach (TLCombinator constructor in constructors)
    {
#>
	[TLObject(0x<#=constructor.Number.ToString("X8") #>)]
	public partial class <#=
    string.Format("{0}{1}", constructor.Name, (typesList != null && typesList.Contains(constructor.Type)) ? " : " + constructor.Type.BuiltInName : String.Empty)
    #>
	{
<#+
        int i = 0;
        foreach (TLCombinatorParameter parameter in constructor.Parameters)
        {
            TLSerializationMode? serModeOverride = parameter.Type.SerializationModeOverride;
#>
		[TLProperty(<#=++i #><#=serModeOverride.HasValue ? string.Format(", {0}", serModeOverride.Value) : String.Empty #>)]
		public <#=parameter.Type.BuiltInName #> <#= parameter.Name #> { get; set; }

<#+
        } 
#>
	}

<#+
    }
} 
#>
